import { initialBoard } from "../initialBoard";
import type { Board } from "../model/board";
import { getPiece } from "../model/board";
import type { Move } from "../model/move";
import type { PieceType, Player } from "../model/piece";
import { convertToJapaneseName } from "../model/piece";
import type { Column, Row, Square } from "../model/square";
import {
    fullWidthToHalfWidth,
    kanjiToNumber,
    kanjiToPieceType,
    numberToKanji,
    pieceTypeToKanji,
} from "../utils/notation";
import { applyMove, generateMoves, initialHands } from "./moveService";
import type { Hands } from "./moveService";

/**
 * KIF形式の棋譜エクスポート/インポート機能
 */

export interface KifGameInfo {
    開始日時?: string;
    終了日時?: string;
    先手?: string;
    後手?: string;
    棋戦?: string;
    手合割?: string;
}

/**
 * KIF形式での手の表現
 */
function formatMoveForKif(move: Move, moveIndex: number): string {
    const moveNumber = moveIndex + 1;

    if (move.type === "drop") {
        const pieceName = pieceTypeToKanji(move.piece.type);
        const toCol = fullWidthNumber(move.to.column);
        const toRow = numberToKanji(move.to.row);
        return `${moveNumber.toString().padStart(4)} ${toCol}${toRow}${pieceName}打`;
    }

    const pieceName = pieceTypeToKanji(move.piece.type);
    const toCol = fullWidthNumber(move.to.column);
    const toRow = numberToKanji(move.to.row);
    const fromStr = `(${move.from.column}${move.from.row})`;
    const promotion = move.promote ? "成" : "";

    return `${moveNumber.toString().padStart(4)} ${toCol}${toRow}${pieceName}${promotion}${fromStr}`;
}

function fullWidthNumber(num: number): string {
    const fullWidthNumbers = ["０", "１", "２", "３", "４", "５", "６", "７", "８", "９"];
    return fullWidthNumbers[num];
}

/**
 * 棋譜をKIF形式でエクスポート
 */
export function exportToKif(moveHistory: Move[], gameInfo: Partial<KifGameInfo> = {}): string {
    const lines: string[] = [];

    // ヘッダー情報
    lines.push("# KIF形式棋譜ファイル Generated by Shogi Web App");
    lines.push(`# 開始日時：${gameInfo.開始日時 || new Date().toLocaleString("ja-JP")}`);
    if (gameInfo.終了日時) {
        lines.push(`# 終了日時：${gameInfo.終了日時}`);
    }
    lines.push(`# 先手：${gameInfo.先手 || "先手"}`);
    lines.push(`# 後手：${gameInfo.後手 || "後手"}`);
    lines.push(`# 棋戦：${gameInfo.棋戦 || "自由対局"}`);
    lines.push(`# 手合割：${gameInfo.手合割 || "平手"}`);
    lines.push("");

    // 初期局面
    lines.push("手数----指手---------消費時間--");

    // 各手の記録
    moveHistory.forEach((move, index) => {
        lines.push(formatMoveForKif(move, index));
    });

    // 対局結果
    if (moveHistory.length > 0) {
        lines.push("");
        lines.push(`まで${moveHistory.length}手で対局終了`);
    }

    return lines.join("\n");
}

/**
 * 指定された移動先に移動できる駒を探す
 */
function findPossibleSources(
    board: Board,
    to: Square,
    pieceType: PieceType,
    player: Player,
    captured: boolean,
): Square[] {
    const possibleSources: Square[] = [];

    // 盤上の全ての駒をチェック
    for (let row = 1; row <= 9; row++) {
        for (let col = 1; col <= 9; col++) {
            const from: Square = {
                row: row as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                column: col as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
            };
            const piece = getPiece(board, from);

            if (!piece || piece.owner !== player) continue;
            if (piece.type !== pieceType) continue;

            // この駒が指定した位置に移動できるかチェック
            const moves = generateMoves(board, from);
            const canMoveToTarget = moves.some((move) => {
                // generateMovesが返すmoveには既にcaptured情報が含まれている
                const hasCapture = !!move.captured;

                return (
                    move.to.row === to.row &&
                    move.to.column === to.column &&
                    hasCapture === captured
                );
            });

            if (canMoveToTarget) {
                possibleSources.push(from);
            }
        }
    }

    return possibleSources;
}

/**
 * KIF記法から移動元を推定する
 */
function inferSourceFromKifMove(
    board: Board,
    to: Square,
    pieceType: PieceType,
    player: Player,
    kifMoveText: string,
    captured: boolean,
): Square | null {
    const possibleSources = findPossibleSources(board, to, pieceType, player, captured);

    if (possibleSources.length === 0) {
        return null;
    }

    if (possibleSources.length === 1) {
        return possibleSources[0];
    }

    // 複数の候補がある場合、KIF記法の付加情報から特定
    // 例: "２六歩(27)" の場合、(27) から移動元を特定
    const sourceMatch = kifMoveText.match(/\(([１２３４５６７８９])([一二三四五六七八九])\)/);
    if (sourceMatch) {
        const [, colStr, rowKanji] = sourceMatch;

        const sourceColumn = fullWidthToHalfWidth(colStr);
        const sourceRow = kanjiToNumber(rowKanji);

        if (sourceColumn && sourceRow) {
            const source: Square = {
                row: sourceRow as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                column: sourceColumn as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
            };

            // 候補の中にこの位置があるかチェック
            if (
                possibleSources.some(
                    (src) => src.row === source.row && src.column === source.column,
                )
            ) {
                return source;
            }
        }
    }

    // その他の曖昧性解決ロジック（右、左、上、下、直など）
    // ここでは簡単のため最初の候補を返す
    console.warn(
        `移動元の曖昧性を解決できませんでした: ${kifMoveText}, 候補数: ${possibleSources.length}`,
    );
    return possibleSources[0];
}

/**
 * KIF形式から初期局面情報を解析
 */
function parseInitialPosition(lines: string[]): {
    board: Board;
    hands: Hands;
    foundPosition: boolean;
} {
    let board = initialBoard;
    const hands = initialHands();
    let foundPosition = false;
    let inBoardSection = false;
    const boardLines: string[] = [];

    for (const line of lines) {
        // コメント行の場合は、# を除去
        const cleanLine = line.startsWith("#") ? line.substring(1).trim() : line;
        const trimmedLine = cleanLine.trim();

        // 持駒情報の解析
        if (trimmedLine.startsWith("先手の持駒：") || trimmedLine.startsWith("下手の持駒：")) {
            foundPosition = true;
            const piecesStr = trimmedLine.split("：")[1];
            if (piecesStr && piecesStr !== "なし") {
                const pieces = piecesStr.trim().split(/\s+/);
                for (const piece of pieces) {
                    const match = piece.match(/^(\d*)(.+)$/);
                    if (match) {
                        const [, countStr, pieceKanji] = match;
                        const count = countStr ? Number.parseInt(countStr, 10) : 1;
                        const pieceType = kanjiToPieceType(pieceKanji);
                        if (pieceType) {
                            const japaneseName = convertToJapaneseName(pieceType);
                            hands.black[japaneseName] += count;
                        }
                    }
                }
            }
        } else if (
            trimmedLine.startsWith("後手の持駒：") ||
            trimmedLine.startsWith("上手の持駒：")
        ) {
            foundPosition = true;
            const piecesStr = trimmedLine.split("：")[1];
            if (piecesStr && piecesStr !== "なし") {
                const pieces = piecesStr.trim().split(/\s+/);
                for (const piece of pieces) {
                    const match = piece.match(/^(\d*)(.+)$/);
                    if (match) {
                        const [, countStr, pieceKanji] = match;
                        const count = countStr ? Number.parseInt(countStr, 10) : 1;
                        const pieceType = kanjiToPieceType(pieceKanji);
                        if (pieceType) {
                            const japaneseName = convertToJapaneseName(pieceType);
                            hands.white[japaneseName] += count;
                        }
                    }
                }
            }
        }

        // 盤面情報の解析（BOD形式）- コメント行も含む
        if (
            trimmedLine.includes("９ ８ ７ ６ ５ ４ ３ ２ １") ||
            line.includes("９ ８ ７ ６ ５ ４ ３ ２ １")
        ) {
            inBoardSection = true;
            foundPosition = true;
            board = {} as Board; // 盤面をクリア
            continue;
        }

        if (inBoardSection && line.includes("|")) {
            // コメント行から盤面情報を抽出
            const boardLine = line.includes("#") ? line.substring(line.indexOf("|")) : line;
            if (boardLine.includes("|") && boardLine.lastIndexOf("|") > boardLine.indexOf("|")) {
                boardLines.push(boardLine);
            }

            if (boardLines.length === 9) {
                // 9行分の盤面情報を解析
                for (let row = 0; row < 9; row++) {
                    const line = boardLines[row];
                    // | ・ ・ ・ ・ ・ ・ ・ ・v玉|二 のような形式
                    const content = line.substring(line.indexOf("|") + 1, line.lastIndexOf("|"));

                    // 各マスの内容を解析（2文字または3文字単位）
                    const cells: string[] = [];
                    let i = 0;
                    while (i < content.length) {
                        // スペースをスキップ
                        if (content[i] === " " || content[i] === "　") {
                            i++;
                            continue;
                        }

                        // ・（空マス）の場合
                        if (content[i] === "・") {
                            cells.push("・");
                            i++;
                        }
                        // v（後手の駒）の場合
                        else if (content[i] === "v") {
                            // v + 駒の漢字を取得
                            if (i + 1 < content.length) {
                                cells.push(content.substring(i, i + 2));
                                i += 2;
                            } else {
                                i++;
                            }
                        }
                        // 先手の駒の場合
                        else if (content[i] !== "|") {
                            // 駒の漢字を取得
                            cells.push(content[i]);
                            i++;
                        } else {
                            i++;
                        }
                    }

                    for (let col = 0; col < cells.length && col < 9; col++) {
                        const cell = cells[col];
                        if (cell && cell !== "・") {
                            const isWhite = cell.startsWith("v");
                            const pieceStr = isWhite ? cell.substring(1) : cell;
                            const promoted = pieceStr.startsWith("+");
                            const pieceKanji = promoted ? pieceStr.substring(1) : pieceStr;
                            const pieceType = kanjiToPieceType(pieceKanji);

                            if (pieceType) {
                                const square: Square = {
                                    row: (row + 1) as Row,
                                    column: (9 - col) as Column,
                                };
                                board[`${square.row}${square.column}`] = {
                                    type: pieceType,
                                    owner: isWhite ? "white" : "black",
                                    promoted,
                                };
                            }
                        }
                    }
                }
                inBoardSection = false;
            }
        }

        // 手数行に到達したら終了
        if (trimmedLine.includes("手数----指手")) {
            break;
        }
    }

    return { board, hands, foundPosition };
}

/**
 * KIF形式の棋譜解析結果
 */
export interface KifParseResult {
    moves: Move[];
    initialBoard?: Board;
    initialHands?: Hands;
}

/**
 * KIF形式の棋譜からMove配列を解析
 * 移動元推定機能付き
 */
export function parseKifMoves(kifContent: string): KifParseResult {
    const lines = kifContent.split("\n");
    const moves: Move[] = [];

    // 初期局面を解析
    const {
        board: initialBoard,
        hands: initialHandsData,
        foundPosition,
    } = parseInitialPosition(lines);

    // 現在の盤面状態を管理（移動元推定のため）
    let currentBoard = foundPosition ? initialBoard : initialBoard;
    let currentHands = foundPosition ? initialHandsData : initialHands();
    let currentPlayer: Player = "black";

    // 手数行を探す
    let inMoveSection = false;

    for (const line of lines) {
        const trimmedLine = line.trim();

        // 手数開始の判定
        if (trimmedLine.includes("手数----指手")) {
            inMoveSection = true;
            continue;
        }

        // 対局終了の判定
        if (trimmedLine.includes("まで") && trimmedLine.includes("手で")) {
            break;
        }

        // 投了の判定
        if (trimmedLine.includes("投了")) {
            break;
        }

        if (!inMoveSection || !trimmedLine) {
            continue;
        }

        // 手の解析（実際のKIF形式に対応）
        // 形式例: "  10 ２三歩打     ( 0:01/00:00:05)" or "   1 ２六歩(27)   ( 0:03/00:00:03)"
        const moveMatch = trimmedLine.match(
            /^\s*(\d+)\s+([１２３４５６７８９])([一二三四五六七八九])([歩香桂銀金角飛王玉])([打取成]?).*$/,
        );

        if (moveMatch) {
            const [, moveNumStr, colStr, rowKanji, pieceKanji, action] = moveMatch;

            // 列の変換（全角数字から半角数字へ）
            const column = fullWidthToHalfWidth(colStr);

            // 行の変換（漢数字）
            const row = kanjiToNumber(rowKanji);

            // 駒の種類変換
            const pieceType = kanjiToPieceType(pieceKanji);

            if (column && row && pieceType && column >= 1 && column <= 9 && row >= 1 && row <= 9) {
                const moveIndex = Number.parseInt(moveNumStr, 10) - 1;
                const isBlack = moveIndex % 2 === 0;
                currentPlayer = isBlack ? "black" : "white";

                const to: Square = {
                    row: row as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                    column: column as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                };

                if (action === "打") {
                    // 駒打ち
                    const move: Move = {
                        type: "drop",
                        to,
                        piece: {
                            type: pieceType,
                            owner: currentPlayer,
                            promoted: false,
                        },
                    };
                    moves.push(move);

                    // 盤面状態を更新（移動元推定のために常に更新が必要）
                    try {
                        const result = applyMove(currentBoard, currentHands, currentPlayer, move);
                        currentBoard = result.board;
                        currentHands = result.hands;
                        currentPlayer = result.nextTurn;
                    } catch (error) {
                        console.error("駒打ちの適用に失敗:", error);
                    }
                } else {
                    // 通常の移動 - 移動元を推定
                    // まず移動先に駒があるかチェックして、capturedフラグを設定
                    const targetPiece = getPiece(currentBoard, to);
                    const captured = action === "取" || !!targetPiece;
                    const promote = action === "成";

                    const from = inferSourceFromKifMove(
                        currentBoard,
                        to,
                        pieceType,
                        currentPlayer,
                        trimmedLine,
                        captured,
                    );

                    if (from) {
                        const piece = getPiece(currentBoard, from);
                        const capturedPiece = getPiece(currentBoard, to);

                        if (piece) {
                            const move: Move = {
                                type: "move",
                                from,
                                to,
                                piece,
                                promote,
                                captured: capturedPiece,
                            };
                            moves.push(move);

                            // 盤面状態を更新（移動元推定のために常に更新が必要）
                            try {
                                const result = applyMove(
                                    currentBoard,
                                    currentHands,
                                    currentPlayer,
                                    move,
                                );
                                currentBoard = result.board;
                                currentHands = result.hands;
                                currentPlayer = result.nextTurn;
                            } catch (error) {
                                console.error("通常移動の適用に失敗:", error);
                            }
                        } else {
                            console.warn("移動元に駒が見つかりません:", from);
                        }
                    } else {
                        console.warn("移動元を推定できませんでした:", trimmedLine);
                    }
                }
            }
        }
    }

    return {
        moves,
        initialBoard: foundPosition ? initialBoard : undefined,
        initialHands: foundPosition ? initialHandsData : undefined,
    };
}

/**
 * KIF形式のバリデーション
 */
export function validateKifFormat(kifContent: string): { valid: boolean; error?: string } {
    if (!kifContent.trim()) {
        return { valid: false, error: "空のファイルです" };
    }

    const lines = kifContent.split("\n");
    const hasHeader = lines.some((line) => line.includes("手数----指手"));

    if (!hasHeader) {
        return { valid: false, error: "KIF形式のヘッダーが見つかりません" };
    }

    return { valid: true };
}
