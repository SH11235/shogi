import type { Move } from "shogi-core";
import {
    type Board,
    type Player,
    type Square,
    applyMove,
    createEmptyHands,
    generateMoves,
    getPiece,
    modernInitialBoard,
} from "shogi-core";

/**
 * KIF形式の棋譜エクスポート/インポート機能
 */

interface KifGameInfo {
    開始日時?: string;
    終了日時?: string;
    先手?: string;
    後手?: string;
    棋戦?: string;
    手合割?: string;
}

// 駒の種類を日本語に変換
function pieceTypeToKanji(pieceType: string): string {
    const pieceMap: Record<string, string> = {
        pawn: "歩",
        lance: "香",
        knight: "桂",
        silver: "銀",
        gold: "金",
        bishop: "角",
        rook: "飛",
        king: "王",
        gyoku: "玉",
    };
    return pieceMap[pieceType] || pieceType;
}

// 数字を漢数字に変換
function numberToKanji(num: number): string {
    const kanjiNumbers = ["", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
    return kanjiNumbers[num] || num.toString();
}

// KIF形式での手の表現
function formatMoveForKif(move: Move, moveIndex: number): string {
    const moveNumber = moveIndex + 1;

    if (move.type === "drop") {
        const pieceName = pieceTypeToKanji(move.piece.type);
        return `${moveNumber.toString().padStart(3)} ${move.to.column}${numberToKanji(move.to.row)}${pieceName}打`;
    }

    const pieceName = pieceTypeToKanji(move.piece.type);
    const capture = move.captured ? "取" : "";
    const promotion = move.promote ? "成" : "";

    return `${moveNumber.toString().padStart(3)} ${move.to.column}${numberToKanji(move.to.row)}${pieceName}${capture}${promotion}`;
}

/**
 * 棋譜をKIF形式でエクスポート
 */
export function exportToKif(moveHistory: Move[], gameInfo: Partial<KifGameInfo> = {}): string {
    const lines: string[] = [];

    // ヘッダー情報
    lines.push("# KIF形式棋譜ファイル Generated by Shogi Web App");
    lines.push(`# 開始日時：${gameInfo.開始日時 || new Date().toLocaleString("ja-JP")}`);
    if (gameInfo.終了日時) {
        lines.push(`# 終了日時：${gameInfo.終了日時}`);
    }
    lines.push(`# 先手：${gameInfo.先手 || "先手"}`);
    lines.push(`# 後手：${gameInfo.後手 || "後手"}`);
    lines.push(`# 棋戦：${gameInfo.棋戦 || "自由対局"}`);
    lines.push(`# 手合割：${gameInfo.手合割 || "平手"}`);
    lines.push("");

    // 初期局面
    lines.push("手数----指手---------消費時間--");

    // 各手の記録
    moveHistory.forEach((move, index) => {
        lines.push(formatMoveForKif(move, index));
    });

    // 対局結果
    if (moveHistory.length > 0) {
        lines.push("");
        lines.push(`まで${moveHistory.length}手で対局終了`);
    }

    return lines.join("\n");
}

/**
 * 指定された移動先に移動できる駒を探す
 */
function findPossibleSources(
    board: Board,
    to: Square,
    pieceType: string,
    player: Player,
    captured: boolean,
): Square[] {
    const possibleSources: Square[] = [];

    // 盤上の全ての駒をチェック
    for (let row = 1; row <= 9; row++) {
        for (let col = 1; col <= 9; col++) {
            const from: Square = {
                row: row as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                column: col as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
            };
            const piece = getPiece(board, from);

            if (!piece || piece.owner !== player) continue;
            if (piece.type !== pieceType) continue;

            // この駒が指定した位置に移動できるかチェック
            const moves = generateMoves(board, from);
            const canMoveToTarget = moves.some((move) => {
                const targetPiece = getPiece(board, to);
                const hasCapture = !!targetPiece;

                return (
                    move.to.row === to.row &&
                    move.to.column === to.column &&
                    hasCapture === captured
                );
            });

            if (canMoveToTarget) {
                possibleSources.push(from);
            }
        }
    }

    return possibleSources;
}

/**
 * KIF記法から移動元を推定する
 */
function inferSourceFromKifMove(
    board: Board,
    to: Square,
    pieceType: string,
    player: Player,
    kifMoveText: string,
    captured: boolean,
): Square | null {
    const possibleSources = findPossibleSources(board, to, pieceType, player, captured);

    if (possibleSources.length === 0) {
        return null;
    }

    if (possibleSources.length === 1) {
        return possibleSources[0];
    }

    // 複数の候補がある場合、KIF記法の付加情報から特定
    // 例: "２六歩(27)" の場合、(27) から移動元を特定
    const sourceMatch = kifMoveText.match(/\(([１２３４５６７８９])([一二三四五六七八九])\)/);
    if (sourceMatch) {
        const [, colStr, rowKanji] = sourceMatch;

        const kanjiToHalfWidth: Record<string, number> = {
            "１": 1,
            "２": 2,
            "３": 3,
            "４": 4,
            "５": 5,
            "６": 6,
            "７": 7,
            "８": 8,
            "９": 9,
        };
        const kanjiToNumber: Record<string, number> = {
            一: 1,
            二: 2,
            三: 3,
            四: 4,
            五: 5,
            六: 6,
            七: 7,
            八: 8,
            九: 9,
        };

        const sourceColumn = kanjiToHalfWidth[colStr];
        const sourceRow = kanjiToNumber[rowKanji];

        if (sourceColumn && sourceRow) {
            const source: Square = {
                row: sourceRow as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                column: sourceColumn as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
            };

            // 候補の中にこの位置があるかチェック
            if (
                possibleSources.some(
                    (src) => src.row === source.row && src.column === source.column,
                )
            ) {
                return source;
            }
        }
    }

    // その他の曖昧性解決ロジック（右、左、上、下、直など）
    // ここでは簡単のため最初の候補を返す
    console.warn(
        `移動元の曖昧性を解決できませんでした: ${kifMoveText}, 候補数: ${possibleSources.length}`,
    );
    return possibleSources[0];
}

/**
 * KIF形式の棋譜からMove配列を解析
 * 移動元推定機能付き
 */
export function parseKifMoves(kifContent: string): Move[] {
    const lines = kifContent.split("\n");
    const moves: Move[] = [];

    // 現在の盤面状態を管理（移動元推定のため）
    let currentBoard = modernInitialBoard;
    let currentHands = createEmptyHands();
    let currentPlayer: Player = "black";

    // 手数行を探す
    let inMoveSection = false;

    for (const line of lines) {
        const trimmedLine = line.trim();

        // 手数開始の判定
        if (trimmedLine.includes("手数----指手")) {
            inMoveSection = true;
            continue;
        }

        // 対局終了の判定
        if (trimmedLine.includes("まで") && trimmedLine.includes("手で")) {
            break;
        }

        // 投了の判定
        if (trimmedLine.includes("投了")) {
            break;
        }

        if (!inMoveSection || !trimmedLine) {
            continue;
        }

        // 手の解析（実際のKIF形式に対応）
        // 形式例: "  10 ２三歩打     ( 0:01/00:00:05)" or "   1 ２六歩(27)   ( 0:03/00:00:03)"
        const moveMatch = trimmedLine.match(
            /^\s*(\d+)\s+([１２３４５６７８９])([一二三四五六七八九])([歩香桂銀金角飛王玉])([打取成]?).*$/,
        );

        if (moveMatch) {
            const [, moveNumStr, colStr, rowKanji, pieceKanji, action] = moveMatch;

            // 列の変換（全角数字から半角数字へ）
            const kanjiToHalfWidth: Record<string, number> = {
                "１": 1,
                "２": 2,
                "３": 3,
                "４": 4,
                "５": 5,
                "６": 6,
                "７": 7,
                "８": 8,
                "９": 9,
            };
            const column = kanjiToHalfWidth[colStr];

            // 行の変換（漢数字）
            const kanjiToNumber: Record<string, number> = {
                一: 1,
                二: 2,
                三: 3,
                四: 4,
                五: 5,
                六: 6,
                七: 7,
                八: 8,
                九: 9,
            };
            const row = kanjiToNumber[rowKanji];

            // 駒の種類変換
            const kanjiToPieceType: Record<string, string> = {
                歩: "pawn",
                香: "lance",
                桂: "knight",
                銀: "silver",
                金: "gold",
                角: "bishop",
                飛: "rook",
                王: "king",
                玉: "gyoku",
            };
            const pieceType = kanjiToPieceType[pieceKanji];

            if (column && row && pieceType && column >= 1 && column <= 9 && row >= 1 && row <= 9) {
                const moveIndex = Number.parseInt(moveNumStr, 10) - 1;
                const isBlack = moveIndex % 2 === 0;
                currentPlayer = isBlack ? "black" : "white";

                const to: Square = {
                    row: row as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                    column: column as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,
                };

                if (action === "打") {
                    // 駒打ち
                    const move: Move = {
                        type: "drop",
                        to,
                        piece: {
                            type: pieceType as
                                | "pawn"
                                | "lance"
                                | "knight"
                                | "silver"
                                | "gold"
                                | "bishop"
                                | "rook"
                                | "king"
                                | "gyoku",
                            owner: currentPlayer,
                            promoted: false,
                        },
                    };
                    moves.push(move);

                    // 盤面状態を更新
                    try {
                        const result = applyMove(currentBoard, currentHands, currentPlayer, move);
                        currentBoard = result.board;
                        currentHands = result.hands;
                        currentPlayer = result.nextTurn;
                    } catch (error) {
                        console.error("駒打ちの適用に失敗:", error);
                    }
                } else {
                    // 通常の移動 - 移動元を推定
                    const captured = action === "取";
                    const promote = action === "成";

                    const from = inferSourceFromKifMove(
                        currentBoard,
                        to,
                        pieceType,
                        currentPlayer,
                        trimmedLine,
                        captured,
                    );

                    if (from) {
                        const piece = getPiece(currentBoard, from);
                        const capturedPiece = getPiece(currentBoard, to);

                        if (piece) {
                            const move: Move = {
                                type: "move",
                                from,
                                to,
                                piece,
                                promote,
                                captured: capturedPiece,
                            };
                            moves.push(move);

                            // 盤面状態を更新
                            try {
                                const result = applyMove(
                                    currentBoard,
                                    currentHands,
                                    currentPlayer,
                                    move,
                                );
                                currentBoard = result.board;
                                currentHands = result.hands;
                                currentPlayer = result.nextTurn;
                            } catch (error) {
                                console.error("通常移動の適用に失敗:", error);
                            }
                        } else {
                            console.warn("移動元に駒が見つかりません:", from);
                        }
                    } else {
                        console.warn("移動元を推定できませんでした:", trimmedLine);
                    }
                }
            }
        }
    }

    return moves;
}

/**
 * KIF形式のバリデーション
 */
export function validateKifFormat(kifContent: string): { valid: boolean; error?: string } {
    if (!kifContent.trim()) {
        return { valid: false, error: "空のファイルです" };
    }

    const lines = kifContent.split("\n");
    const hasHeader = lines.some((line) => line.includes("手数----指手"));

    if (!hasHeader) {
        return { valid: false, error: "KIF形式のヘッダーが見つかりません" };
    }

    return { valid: true };
}
